<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PDF 簽名系統</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/signature_pad@4.1.6/dist/signature_pad.umd.min.js"></script>
  <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
  <style>
    body { font-family: sans-serif; padding: 10px; }
    #pdf-container { max-height: 500px; overflow-x: auto; border: 1px solid #ccc; }
    .pdf-page { position: relative; margin-bottom: 20px; }
    canvas { width: 100%; height: auto; border: 1px solid #ccc; }
    .signature-img {
      position: absolute;
      width: 120px;
      height: auto;
      touch-action: none;
      cursor: move;
      z-index: 10;
      transform-origin: top left;
      border: 2px solid transparent;
    }
    .signature-img.selected {
      border: 2px dashed red;
    }
    #signature-pad {
      width: 100%;
      max-width: 600px;
      height: 200px;
      border: 1px solid #000;
      touch-action: none;
    }
    button { margin: 5px 5px 5px 0; font-size: 16px; }
    .controls { margin-bottom: 10px; }
    #color-picker { margin-right: 10px; }
  </style>
</head>
<body>

<h2>PDF 簽名系統</h2>

<input type="file" id="pdf-upload" accept="application/pdf,image/*" /><br /><br />
<div id="pdf-container"></div>

<h3>手寫簽名：</h3>
<div>
  <label for="color-picker">簽名顏色：</label>
  <input type="color" id="color-picker" value="#000000" list="color-list" />
  <datalist id="color-list">
    <option value="#000000">黑色</option>
    <option value="#ff0000">紅色</option>
    <option value="#0000ff">藍色</option>
    <option value="#008000">綠色</option>
    <!-- 不要加白色 -->
  </datalist>
</div>
<canvas id="signature-pad"></canvas><br />

<div class="controls">
  <button onclick="clearSignature()">清除簽名</button>
  <button onclick="createDraggableSignature()">建立拖曳簽名</button>
  <button onclick="increaseSize()">放大簽名</button>
  <button onclick="decreaseSize()">縮小簽名</button>
  <button onclick="deleteSelectedSignature()">刪除選中簽名</button>
</div>

<br />
<button onclick="signAndDownload()">簽名並下載 PDF</button>
<button onclick="signAndDownloadJPGAll()">簽名頁下載 JPG</button>

<script>
const canvas = document.getElementById('signature-pad');
const colorPicker = document.getElementById('color-picker');
let signaturePad;

// 用於判斷目前是否為圖片模式
let isImageMode = false;
let imageInfo = null;

function resizeCanvas() {
  // 儲存原簽名內容
  let data = signaturePad ? signaturePad.toData() : null;

  const ratio = Math.max(window.devicePixelRatio || 1, 1);
  const width = canvas.offsetWidth;
  const height = canvas.offsetHeight;
  canvas.width = width * ratio;
  canvas.height = height * ratio;
  canvas.getContext("2d").scale(ratio, ratio);

  // 重建 signaturePad
  signaturePad = new SignaturePad(canvas, {
    backgroundColor: 'rgba(0,0,0,0)',
    minWidth: 1,
    maxWidth: 2,
    penColor: colorPicker.value
  });

  // 還原簽名內容
  if (data && data.length > 0) {
    signaturePad.fromData(data);
  }
}
resizeCanvas();
window.addEventListener("orientationchange", resizeCanvas);
window.addEventListener("resize", resizeCanvas);

// 修正 BUG: 換顏色時先清空畫布
colorPicker.addEventListener('input', function () {
  if (signaturePad) {
    signaturePad.clear(); // 先清空畫布與筆跡資料
    signaturePad.penColor = colorPicker.value;
  }
  // 禁止選白色
  if (colorPicker.value.toLowerCase() === "#ffffff") {
    alert("不允許選擇白色，請換其他顏色！");
    colorPicker.value = "#000000";
    signaturePad.penColor = "#000000";
  }
});

let pdfDoc = null;
let pdfOriginalBytes = null;
let scale = 1.5;
let currentPageNumber = 1;
let signatureImages = [];
let currentScale = 1;
let selectedSignature = null;

const pdfContainer = document.getElementById("pdf-container");

document.getElementById("pdf-upload").addEventListener("change", async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const fileType = file.type;

  // 清空原本畫面
  pdfContainer.innerHTML = '';
  signatureImages = [];
  currentPageNumber = 1;
  isImageMode = false;
  imageInfo = null;

  if (fileType === "application/pdf") {
    // PDF 處理邏輯
    pdfOriginalBytes = await file.arrayBuffer();
    const typedArray = new Uint8Array(pdfOriginalBytes);
    pdfDoc = await pdfjsLib.getDocument(typedArray).promise;
    for (let i = 1; i <= pdfDoc.numPages; i++) {
      const page = await pdfDoc.getPage(i);
      const viewport = page.getViewport({ scale });

      const canvas = document.createElement("canvas");
      canvas.width = viewport.width;
      canvas.height = viewport.height;

      const ctx = canvas.getContext("2d");
      await page.render({ canvasContext: ctx, viewport }).promise;

      const wrapper = document.createElement("div");
      wrapper.classList.add("pdf-page");
      wrapper.dataset.pageNumber = i;
      wrapper.appendChild(canvas);
      pdfContainer.appendChild(wrapper);

      wrapper.addEventListener("click", () => {
        currentPageNumber = i;
        alert("已選擇第 " + i + " 頁");
      });
    }
    isImageMode = false;
  } else if (fileType.startsWith("image/")) {
    // 圖檔處理邏輯
    const imgURL = URL.createObjectURL(file);
    const img = new Image();
    img.src = imgURL;
    img.onload = function () {
      const canvasImg = document.createElement("canvas");
      canvasImg.width = img.width;
      canvasImg.height = img.height;
      const ctx = canvasImg.getContext("2d");
      ctx.drawImage(img, 0, 0);

      const wrapper = document.createElement("div");
      wrapper.classList.add("pdf-page");
      wrapper.dataset.pageNumber = 1;
      wrapper.appendChild(canvasImg);
      pdfContainer.appendChild(wrapper);

      currentPageNumber = 1;
      pdfDoc = null; // 圖檔不需 PDFDoc
      pdfOriginalBytes = null;
      isImageMode = true;
      imageInfo = {
        width: img.width,
        height: img.height,
        url: imgURL
      };

      wrapper.addEventListener("click", () => {
        currentPageNumber = 1;
        alert("已選擇第 1 頁");
      });
    };
  } else {
    alert("只支援 PDF 或圖檔！");
  }
});

function clearSignature() {
  signaturePad.clear();
}

function increaseSize() {
  currentScale *= 1.2;
  updateImgScale();
}

function decreaseSize() {
  currentScale /= 1.2;
  updateImgScale();
}

function updateImgScale() {
  signatureImages.forEach(({ imgElement }) => {
    imgElement.style.transform = `scale(${currentScale})`;
  });
}

function createDraggableSignature() {
  if (signaturePad.isEmpty()) {
    alert("請先簽名！");
    return;
  }

  const dataURL = signaturePad.toDataURL("image/png");
  const img = document.createElement("img");
  img.src = dataURL;
  img.classList.add("signature-img");
  img.style.transform = `scale(${currentScale})`;

  const wrapper = document.querySelector(`.pdf-page[data-page-number="${currentPageNumber}"]`);
  if (!wrapper) {
    alert("請先選擇一頁");
    return;
  }

  wrapper.appendChild(img);
  img.style.left = "30px";
  img.style.top = "30px";

  let offsetX = 0, offsetY = 0;
  let startDist = null;

  const dragStart = (e) => {
    e.preventDefault();
    const point = e.touches ? e.touches[0] : e;
    offsetX = point.clientX - img.getBoundingClientRect().left;
    offsetY = point.clientY - img.getBoundingClientRect().top;

    document.addEventListener("mousemove", dragMove);
    document.addEventListener("mouseup", dragEnd);
    document.addEventListener("touchmove", dragMove, { passive: false });
    document.addEventListener("touchend", dragEnd);
  };

  const dragMove = (e) => {
    if (e.touches && e.touches.length === 2) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (startDist) {
        const scaleChange = dist / startDist;
        currentScale *= scaleChange;
        updateImgScale();
      }
      startDist = dist;
      e.preventDefault();
      return;
    }

    const point = e.touches ? e.touches[0] : e;
    const wrapperRect = wrapper.getBoundingClientRect();
    let x = point.clientX - wrapperRect.left - offsetX;
    let y = point.clientY - wrapperRect.top - offsetY;

    x = Math.max(0, Math.min(x, wrapperRect.width - img.offsetWidth * currentScale));
    y = Math.max(0, Math.min(y, wrapperRect.height - img.offsetHeight * currentScale));

    img.style.left = `${x}px`;
    img.style.top = `${y}px`;
  };

  const dragEnd = () => {
    startDist = null;
    document.removeEventListener("mousemove", dragMove);
    document.removeEventListener("mouseup", dragEnd);
    document.removeEventListener("touchmove", dragMove);
    document.removeEventListener("touchend", dragEnd);
  };

  img.addEventListener("mousedown", dragStart);
  img.addEventListener("touchstart", dragStart, { passive: false });

  // 桌面點擊
  img.addEventListener("click", (e) => {
    selectSignature(img);
    e.stopPropagation();
  });

  // 手機點擊支援
  let touchStartTime = 0;
  let moved = false;

  img.addEventListener("touchstart", (e) => {
    touchStartTime = Date.now();
    moved = false;
  });

  img.addEventListener("touchmove", () => {
    moved = true;
  });

  img.addEventListener("touchend", () => {
    const touchDuration = Date.now() - touchStartTime;
    if (!moved && touchDuration < 300) {
      selectSignature(img);
    }
  });

  function selectSignature(img) {
    document.querySelectorAll(".signature-img").forEach(el => el.classList.remove("selected"));
    img.classList.add("selected");
    selectedSignature = img;
  }

  signatureImages.push({
    page: currentPageNumber,
    imgElement: img,
    dataURL: dataURL
  });

  // 修正顏色交錯BUG: 拖曳簽名後強制清空畫布與paths
  signaturePad.clear();
}

function deleteSelectedSignature() {
  if (selectedSignature) {
    selectedSignature.remove();
    signatureImages = signatureImages.filter(sig => sig.imgElement !== selectedSignature);
    selectedSignature = null;
  } else {
    alert("請先點選要刪除的簽名！");
  }
}

async function signAndDownload() {
  if (pdfDoc) {
    // PDF 檔案原本邏輯
    if (signatureImages.length === 0) {
      alert("請上傳 PDF 並加入簽名！");
      return;
    }
    const pdfLibDoc = await PDFLib.PDFDocument.load(pdfOriginalBytes);
    const pages = pdfLibDoc.getPages();

    for (const sig of signatureImages) {
      const pageIndex = sig.page - 1;
      const page = pages[pageIndex];
      const { width: pdfPageWidth, height: pdfPageHeight } = page.getSize();

      const wrapper = document.querySelector(`.pdf-page[data-page-number="${sig.page}"]`);
      const canvas = wrapper.querySelector("canvas");
      const canvasRect = canvas.getBoundingClientRect();
      const imgRect = sig.imgElement.getBoundingClientRect();

      const pngImage = await pdfLibDoc.embedPng(sig.dataURL);
      const pxToPt = pdfPageWidth / canvasRect.width;

      const displayWidth = sig.imgElement.offsetWidth * currentScale;
      const displayHeight = sig.imgElement.offsetHeight * currentScale;
      const pdfWidth = displayWidth * pxToPt;
      const pdfHeight = displayHeight * pxToPt;

      const x = (imgRect.left - canvasRect.left) * pxToPt;
      const y = pdfPageHeight - (imgRect.top - canvasRect.top) * pxToPt - pdfHeight;

      page.drawImage(pngImage, {
        x,
        y,
        width: pdfWidth,
        height: pdfHeight,
      });
    }

    const pdfBytes = await pdfLibDoc.save();
    const blob = new Blob([pdfBytes], { type: "application/pdf" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = "signed.pdf";
    link.click();
  } else if (isImageMode) {
    // 圖檔簽名合成 PDF
    const wrapper = document.querySelector('.pdf-page[data-page-number="1"]');
    if (!wrapper) {
      alert("找不到圖檔頁面！");
      return;
    }
    const baseCanvas = wrapper.querySelector("canvas");

    // 疊上簽名
    signatureImages
      .filter(sig => sig.page === 1)
      .forEach(sig => {
        const img = sig.imgElement;
        const baseRect = baseCanvas.getBoundingClientRect();
        const imgRect = img.getBoundingClientRect();
        const scaleX = baseCanvas.width / baseRect.width;
        const scaleY = baseCanvas.height / baseRect.height;

        const x = (imgRect.left - baseRect.left) * scaleX;
        const y = (imgRect.top - baseRect.top) * scaleY;
        const w = img.offsetWidth * currentScale * scaleX;
        const h = img.offsetHeight * currentScale * scaleY;

        const tempImg = new window.Image();
        tempImg.src = sig.dataURL;
        baseCanvas.getContext('2d').drawImage(tempImg, x, y, w, h);
      });

    // 將合成後的 canvas 轉出 PNG
    const mergedDataURL = baseCanvas.toDataURL("image/png");

    // 用 PDF-Lib 建立 PDF
    const pdfDocNew = await PDFLib.PDFDocument.create();
    const pngImage = await pdfDocNew.embedPng(mergedDataURL);
    const page = pdfDocNew.addPage([baseCanvas.width, baseCanvas.height]);
    page.drawImage(pngImage, {
      x: 0, y: 0,
      width: baseCanvas.width, height: baseCanvas.height
    });

    // 下載 PDF
    const pdfBytes = await pdfDocNew.save();
    const blob = new Blob([pdfBytes], { type: "application/pdf" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = "signed_image.pdf";
    link.click();
  } else {
    alert("請上傳 PDF 或圖檔，並加入簽名！");
  }
}

// 優化：每一頁有簽名都下載 JPG
async function signAndDownloadJPGAll() {
  if (pdfDoc) {
    if (signatureImages.length === 0) {
      alert("請上傳 PDF 並加入簽名！");
      return;
    }
    // 依頁號分組簽名
    const sigByPage = {};
    signatureImages.forEach(sig => {
      if (!sigByPage[sig.page]) sigByPage[sig.page] = [];
      sigByPage[sig.page].push(sig);
    });

    // 依照有簽名的頁面逐頁下載 JPG
    for (const pageNumStr of Object.keys(sigByPage)) {
      const pageNum = Number(pageNumStr);
      const wrapper = document.querySelector(`.pdf-page[data-page-number="${pageNum}"]`);
      const baseCanvas = wrapper.querySelector("canvas");

      // 複製 canvas 作為底圖
      const outCanvas = document.createElement('canvas');
      outCanvas.width = baseCanvas.width;
      outCanvas.height = baseCanvas.height;
      const ctx = outCanvas.getContext('2d');
      ctx.drawImage(baseCanvas, 0, 0);

      // 疊上所有該頁簽名
      sigByPage[pageNum].forEach(sig => {
        const img = sig.imgElement;
        const baseRect = baseCanvas.getBoundingClientRect();
        const imgRect = img.getBoundingClientRect();
        const scaleX = baseCanvas.width / baseRect.width;
        const scaleY = baseCanvas.height / baseRect.height;

        const x = (imgRect.left - baseRect.left) * scaleX;
        const y = (imgRect.top - baseRect.top) * scaleY;
        const w = img.offsetWidth * currentScale * scaleX;
        const h = img.offsetHeight * currentScale * scaleY;

        const tempImg = new window.Image();
        tempImg.src = sig.dataURL;
        ctx.drawImage(tempImg, x, y, w, h);
      });

      // 下載該頁 JPG
      await new Promise(resolve => {
        outCanvas.toBlob(function(blob) {
          const link = document.createElement("a");
          link.href = URL.createObjectURL(blob);
          link.download = `signed_page${pageNum}.jpg`;
          link.click();
          resolve();
        }, "image/jpeg", 0.95);
      });
    }
  } else if (isImageMode) {
    // 只處理第1頁
    if (signatureImages.length === 0) {
      alert("請上傳圖檔並加入簽名！");
      return;
    }
    const wrapper = document.querySelector('.pdf-page[data-page-number="1"]');
    const baseCanvas = wrapper.querySelector("canvas");

    // 疊上簽名
    signatureImages
      .filter(sig => sig.page === 1)
      .forEach(sig => {
        const img = sig.imgElement;
        const baseRect = baseCanvas.getBoundingClientRect();
        const imgRect = img.getBoundingClientRect();
        const scaleX = baseCanvas.width / baseRect.width;
        const scaleY = baseCanvas.height / baseRect.height;

        const x = (imgRect.left - baseRect.left) * scaleX;
        const y = (imgRect.top - baseRect.top) * scaleY;
        const w = img.offsetWidth * currentScale * scaleX;
        const h = img.offsetHeight * currentScale * scaleY;

        const tempImg = new window.Image();
        tempImg.src = sig.dataURL;
        baseCanvas.getContext('2d').drawImage(tempImg, x, y, w, h);
      });

    // 下載 JPG
    baseCanvas.toBlob(function(blob) {
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = "signed_image.jpg";
      link.click();
    }, "image/jpeg", 0.95);
  } else {
    alert("請上傳 PDF 或圖檔，並加入簽名！");
  }
}
</script>
</body>
</html>
